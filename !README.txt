Реализованы все задачи

Замечания и оговорки
1. SDK VK оказался несколько кривой, в частности при выполнения запроса с отключенным интернетом, запрос становится бесконечном, ради этого я даже открыл проблему на гитхабе
https://github.com/VKCOM/vk-android-sdk/issues/426
при этом форма авторизации работает нормально даже с выключенным интернетом.
Поэтому СДК я использовал лишь для авторизации, с целью получения токена и ID залогиниашегося пользователя, которые сохраняются в SharedPreferences. Получение остальных данных реализовано через стандартное API VK с помощью Retrofit

2. Непосредственно в самом АПИ ВК есть неприятная особенность. Заключается в следующем:
	API иногда отдает некорректный результат, смысл его такой: 
	Сделали первый запрос, получили список.
    Далее сделали второй запрос получили второй список, и бывает так, что в этом списке первый пользователь тот же самый как и последний в предыдущем, а бывает, что выдается нормально. Так что если в списке увидите одинаковые записи, то я тут непричем, проверял вручную, все так и есть. Разбираться с этим багом в данном проекте не вижу смысла.

3. Попытался впервые в жизни использовать компонеты из Material Design. Использовал вот эту билблиотеку https://github.com/material-components/material-components-android
делал все по книжке, получилось по моему так себе... был бы признателен за пинок в этом направлении

Как это работает:
1. Для получения данных используется 2 вида запросов. 

первый запрос отправляется на конечную точку API "https://api.vk.com//method/{method_name}" и используется для поиска пользователей и получения друзей конкретного пользователя.
при этом в зависимости от необходимости, что нужно получить, используются вместо {method_name} подаствляются методы  API VK "users.search" и "friends.get" (подстановка производится в соотвествующем презентере) 
Для того, чтобы API VK правильно отработал запросы, используются комбинации параметров q={поисковый запрос} и user_id={id пользователя}.
В случае, если от апи запрашивается результат поиска, то в q= передается поисковый запрос, а user_id=null.
В случае, если запрашиваетсясписок друзей, то отправляется q=null, а user_id= отправляется идентификатор пользователя.
В программе это позволило для обеих случаев организовать один интерфейс ретрофита.
Вероятно не стоило смешивать эти вызовы, но мне показалось, что так будет лучше, так как получилось меньше однообразного кода.

Второй запрос отправляется на конечную точку API "https://api.vk.com/method/users.get", в который отправляется id залогиненого пользователя. Данный запрос необходим для получения полной информации текущего пользователя.

Хотелось организовать получение этих данных через первый интерфейс, так как JSON результатов первого и второго методов отличаются в незначительной степени, но я не смог придумать, как правильно сконвертировать результат второго запроса в первый. Буду признателен за науку.

2. Пагинация. 
После того, как пользователь нажмет кнопку "поиск", делается запрос к АПИ ВК для выборки из поиска 20 элементов, начиная с позиции 0 (в методах АПИ ВК это count и offset). параметр count можно задавать в константах приложения.
При получении ответа от сервера приложение проводит некоторый анализ входных данных, которые затем эмитируются Observable. observer, определенный в презентере получает эти данные и отправляет список во вью (в моем случае вью это активити), который отображается в recyclerview. 
В свою очередь recyclerview наблюдает за скроллиногом данных внутри себя, и при скролле вниз сообщает, что данные заканчиваются и нужна новая порция. далее эта команда идет по цепочке Презентер -> репозиторий -> Источник данных -> АПИ ВК. 
Источник данных в свою очередь увеличивает offset и запрашивает новую порцию.

Замечено, что АПИ ВК хоть в методе поиска, хоть в методе получения друзей выдает массив результатов разной длины, поэтому инкремент offset реализован в самом источнике данных.

Скролл списка друзей организован таким же образом.

3. pull to refresh здесь я несколько не понял какой в нем смысл, если мы листаем список, а он подгружается снизу. Может быть нужно было сделать так, чтобы в принципе показывалась только одна станица, то есть при подгрузке данных внизу, все те, что уже показаны в ресайклере были бы "забыты". Но это в первых не логично, во вторых не красиво. Поэтому я сделал эту функцию просто как поиск по тому же самому запросу, но с нулевой позиции (offset = 0)

4. отображение данных
для отображения результатов поиска и списка друзей можно использовать одну и ту же размету, и более того, эти фичи несут в себе практически одинаковую реализацию. поэтому была определена базовая активити, с реализацией общих методов, а для каждой из фичей баовая активити была 
расширена.

То же самое было сделано для просмотра информации о пользователе и информации о себе.

Но в силу свого малого опыта, у меня как то не получилось в базовую активити слушатели скролла от ресайклера, слушателя обновления данных у них практически одинаковая реализация для всех активити. Вроде бы логично было бы их передавать в активити-наследника через интерфейсы, но что-то как-то не получилось.... Если это возможно, а это наверняка возможно, был бы благодарен за объяснение. 

5. дополнительные фичи
когда приложение загружает новую порцию данных, само собой внихзу появляется индикатор загрузки, но если загрузка не удалась по каким-то причинам, то наего месте появляется сообщение об ошибке загрузки и кнопка повтора, нажав на которую в источник данных по цепочке передается команда на повторный запрос данных с теми же праметрами.

если от АПИ ВК приходит валидный ответ, но количество элементов при этом равно нулю, то внизу списка добавляется элемент, сообщающий, что для даннго запроса данных больше нет и не будет.

6. Архитектура
Старался придерживаться "чистой архитектуры" наверняка в полной степени это не удалось, но я старался (:
в целом приложение разделено на слои
	- слой UI содержит в себе активити, слушатели, адаптеры для ресайклера, интерфейсы вьюшек
	- слой презентеров. управляют отображением состояний во вью, подписываются на репозиторий для получения данных, отправляют репозиторию команды на получение данных
	- слой данных. содержит в себе 2 слоя, это репозиторий и апи.
			- репозиторий служит прослойкой между данными и презенетером. реализует логику получения данных
	
			- апи служит непосредственно для организации запросов к АПИ ВК, получение этих данных, их валидацию и первичную обработку. Хотя наверное правильнее было бы в апи только получение данных и ничего больше,а в репозитории все остальное. Но это я понял только в тот момент, когда пишу эту строку. Так же слой апи занимается анализом состояния сети и эмитированием состояния этой самой сети.
			
	- слой приложения. в нем орагнизован граф зависимостей, инициализация контекста приложения и определены константы.

7. Что еще?..
да вроде бы все.. может о чем-то забыл, если что вдруг непонятно - спрашивайте, мой телеграм я указал в почте, вместе с ссылкой на репозиторий.
Хотелось бы сказать спасибо, хорошее задание, размяло мозги, несколько прокачало мой общий уровень в разработке.
